<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: json-README
  
    &mdash; Web portal for RDF.rb.
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: json-README</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><p>== Description</p>

<p>This is a implementation of the JSON specification according to RFC 4627
http://www.ietf.org/rfc/rfc4627.txt . Starting from version 1.0.0 on there
will be two variants available:</p>

<ul>
<li>A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.</li>
<li>The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler
http://www.cs.queensu.ca/~thurston/ragel .</li>
</ul>


<p>Both variants of the JSON generator generate UTF-8 character sequences by
default. If an :ascii_only option with a true value is given, they escape all
non-ASCII and control characters with \uXXXX escape sequences, and support
UTF-16 surrogate pairs in order to be able to generate the whole range of
unicode code points.</p>

<p>All strings, that are to be encoded as JSON strings, should be UTF-8 byte
sequences on the Ruby side. To encode raw binary strings, that aren't UTF-8
encoded, please use the to<em>json</em>raw_object method of String (which produces
an object, that contains a byte array) and decode the result on the receiving
endpoint.</p>

<p>The JSON parsers can parse UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE
JSON documents under Ruby 1.8. Under Ruby 1.9 they take advantage of Ruby's
M17n features and can parse all documents which have the correct
String#encoding set. If a document string has ASCII-8BIT as an encoding the
parser attempts to figure out which of the UTF encodings from above it is and
trys to parse it.</p>

<p>== Installation</p>

<p>It's recommended to use the extension variant of JSON, because it's faster than
the pure ruby variant. If you cannot build it on your system, you can settle
for the latter.</p>

<p>Just type into the command line as root:</p>

<p>  # rake install</p>

<p>The above command will build the extensions and install them on your system.</p>

<p>  # rake install_pure</p>

<p>or</p>

<p>  # ruby install.rb</p>

<p>will just install the pure ruby implementation of JSON.</p>

<p>If you use Rubygems you can type</p>

<p>  # gem install json</p>

<p>instead, to install the newest JSON version.</p>

<p>There is also a pure ruby json only variant of the gem, that can be installed
with:</p>

<p>  # gem install json_pure</p>

<p>== Compiling the extensions yourself</p>

<p>If you want to build the extensions yourself you need rake:</p>

<p>  You can get it from rubyforge:</p>

<pre class="code"><span class='id http'>http</span><span class='symbol'>:/</span><span class='op'>/</span><span class='id rubyforge'>rubyforge</span><span class='period'>.</span><span class='id org'>org</span><span class='op'>/</span><span class='id projects'>projects</span><span class='op'>/</span><span class='id rake'>rake</span>
</pre>

<p>  or just type</p>

<p>  # gem install rake</p>

<p>  for the installation via rubygems.</p>

<p>If you want to create the parser.c file from its parser.rl file or draw nice
graphviz images of the state machines, you need ragel from: http://www.cs.queensu.ca/~thurston/ragel</p>

<p>== Usage</p>

<p>To use JSON you can
  require 'json'
to load the installed variant (either the extension 'json' or the pure
variant 'json_pure'). If you have installed the extension variant, you can
pick either the extension variant or the pure variant by typing
  require 'json/ext'
or
  require 'json/pure'</p>

<p>Now you can parse a JSON document into a ruby data structure by calling</p>

<p>  JSON.parse(document)</p>

<p>If you want to generate a JSON document from a ruby data structure call
  JSON.generate(data)</p>

<p>You can also use the pretty<em>generate method (which formats the output more
verbosely and nicely) or fast</em>generate (which doesn't do any of the security
checks generate performs, e. g. nesting deepness checks).</p>

<p>To create a valid JSON document you have to make sure, that the output is
embedded in either a JSON array [] or a JSON object {}. The easiest way to do
this, is by putting your values in a Ruby Array or Hash instance.</p>

<p>There are also the JSON and JSON[] methods which use parse on a String or
generate a JSON document from an array or hash:</p>

<p>  document = JSON 'test'  => 23 # => "\&quot;test\&quot;:23"
  document = JSON['test'] => 23 # => "\&quot;test\&quot;:23"</p>

<p>and</p>

<p>  data = JSON '&quot;test&quot;:23'  # => &quot;test&quot;=&gt;23
  data = JSON['&quot;test&quot;:23'] # => &quot;test&quot;=&gt;23</p>

<p>You can choose to load a set of common additions to ruby core's objects if
you
  require 'json/add/core'</p>

<p>After requiring this you can, e. g., serialise/deserialise Ruby ranges:</p>

<p>  JSON JSON(1..10) # => 1..10</p>

<p>To find out how to add JSON support to other or your own classes, read the
section "More Examples" below.</p>

<p>To get the best compatibility to rails' JSON implementation, you can
  require 'json/add/rails'</p>

<p>Both of the additions attempt to require 'json' (like above) first, if it has
not been required yet.</p>

<p>== More Examples</p>

<p>To create a JSON document from a ruby data structure, you can call
JSON.generate like that:</p>

<p> json = JSON.generate [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]
 # => "[1,2,\&quot;a\&quot;:3\&quot;a\&quot;:3.141,false,true,null,\"4..10\"]"</p>

<p>To get back a ruby data structure from a JSON document, you have to call
JSON.parse on it:</p>

<p> JSON.parse json
 # => [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, "4..10"]</p>

<p>Note, that the range from the original data structure is a simple
string now. The reason for this is, that JSON doesn't support ranges
or arbitrary classes. In this case the json library falls back to call
Object#to<em>json, which is the same as #to</em>s.to_json.</p>

<p>It's possible to add JSON support serialization to arbitrary classes by
simply implementing a more specialized version of the #to<em>json method, that
should return a JSON object (a hash converted to JSON with #to</em>json) like
this (don't forget the *a for all the arguments):</p>

<p> class Range
   def to_json(*a)</p>

<pre class="code"> <span class='lbrace'>{</span>
   <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>json_class</span><span class='tstring_end'>'</span></span>   <span class='op'>=&gt;</span> <span class='kw'>self</span><span class='period'>.</span><span class='id class'>class</span><span class='period'>.</span><span class='id name'>name</span><span class='comma'>,</span> <span class='comment'># = 'Range'
</span>   <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>data</span><span class='tstring_end'>'</span></span>         <span class='op'>=&gt;</span> <span class='lbracket'>[</span> <span class='id first'>first</span><span class='comma'>,</span> <span class='id last'>last</span><span class='comma'>,</span> <span class='id exclude_end?'>exclude_end?</span> <span class='rbracket'>]</span>
 <span class='rbrace'>}</span><span class='period'>.</span><span class='id to_json'>to_json</span><span class='lparen'>(</span><span class='op'>*</span><span class='id a'>a</span><span class='rparen'>)</span>
</pre>

<p>   end
 end</p>

<p>The hash key 'json_class' is the class, that will be asked to deserialise the
JSON representation later. In this case it's 'Range', but any namespace of
the form 'A::B' or '::A::B' will do. All other keys are arbitrary and can be
used to store the necessary data to configure the object to be deserialised.</p>

<p>If a the key 'json<em>class' is found in a JSON object, the JSON parser checks
if the given class responds to the json</em>create class method. If so, it is
called with the JSON object converted to a Ruby hash. So a range can
be deserialised by implementing Range.json_create like this:</p>

<p> class Range
   def self.json_create(o)</p>

<pre class="code"> <span class='id new'>new</span><span class='lparen'>(</span><span class='op'>*</span><span class='id o'>o</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>data</span><span class='tstring_end'>'</span></span><span class='rbracket'>]</span><span class='rparen'>)</span>
</pre>

<p>   end
 end</p>

<p>Now it possible to serialise/deserialise ranges as well:</p>

<p> json = JSON.generate [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]
 # => "[1,2,\&quot;a\&quot;:3\&quot;a\&quot;:3.141,false,true,null,\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]]"
 JSON.parse json
 # => [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]</p>

<p>JSON.generate always creates the shortest possible string representation of a
ruby data structure in one line. This is good for data storage or network
protocols, but not so good for humans to read. Fortunately there's also
JSON.pretty<em>generate (or JSON.pretty</em>generate) that creates a more readable
output:</p>

<p> puts JSON.pretty_generate([1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10])
 [
   1,
   2,
   {</p>

<pre class="code"> &quot;a&quot;: 3.141
</pre>

<p>   },
   false,
   true,
   null,
   {</p>

<pre class="code"> &quot;json_class&quot;: &quot;Range&quot;,
 &quot;data&quot;: [
   4,
   10,
   false
 ]
</pre>

<p>   }
 ]</p>

<p>There are also the methods Kernel#j for generate, and Kernel#jj for
pretty_generate output to the console, that work analogous to Core Ruby's p and
the pp library's pp methods.</p>

<p>The script tools/server.rb contains a small example if you want to test, how
receiving a JSON object from a webrick server in your browser with the
javasript prototype library http://www.prototypejs.org works.</p>

<p>== Speed Comparisons</p>

<p>I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the JSON-parser to estimate the speed up in the C
extension:</p>

<p> Comparing times (call<em>time</em>mean):
  1 ParserBenchmarkExt#parser   900 repeats:</p>

<pre class="code">    553.922304770 (  real) -&gt;   21.500x 
      0.001805307
</pre>

<p>  2 ParserBenchmarkYAML#parser  1000 repeats:</p>

<pre class="code">    224.513358139 (  real) -&gt;    8.714x 
      0.004454078
</pre>

<p>  3 ParserBenchmarkPure#parser  1000 repeats:</p>

<pre class="code">     26.755020642 (  real) -&gt;    1.038x 
      0.037376163
</pre>

<p>  4 ParserBenchmarkRails#parser 1000 repeats:</p>

<pre class="code">     25.763381731 (  real) -&gt;    1.000x 
      0.038814780
        calls/sec (  time) -&gt;    speed  covers
        secs/call
</pre>

<p>In the table above 1 is JSON::Ext::Parser, 2 is YAML.load with YAML
compatbile JSON document, 3 is is JSON::Pure::Parser, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport JSON-decoder converts the
input first to YAML and then uses the YAML-parser, the conversion seems to
slow it down so much that it is only as fast as the JSON::Pure::Parser!</p>

<p>If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the JSON::Pure::Parser runs:</p>

<p> Comparing times (call<em>time</em>median):
  1 ParserBenchmarkExt#parser   900 repeats:</p>

<pre class="code">    800.592479481 (  real) -&gt;   26.936x 
      0.001249075
</pre>

<p>  2 ParserBenchmarkYAML#parser  1000 repeats:</p>

<pre class="code">    271.002390644 (  real) -&gt;    9.118x 
      0.003690004
</pre>

<p>  3 ParserBenchmarkRails#parser 1000 repeats:</p>

<pre class="code">     30.227910865 (  real) -&gt;    1.017x 
      0.033082008
</pre>

<p>  4 ParserBenchmarkPure#parser  1000 repeats:</p>

<pre class="code">     29.722384421 (  real) -&gt;    1.000x 
      0.033644676
        calls/sec (  time) -&gt;    speed  covers
        secs/call
</pre>

<p>I have benchmarked the JSON-Generator as well. This generated a few more
values, because there are different modes that also influence the achieved
speed:</p>

<p> Comparing times (call<em>time</em>mean):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:</p>

<pre class="code">    547.354332608 (  real) -&gt;   15.090x 
      0.001826970
</pre>

<p>  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:</p>

<pre class="code">    443.968212317 (  real) -&gt;   12.240x 
      0.002252414
</pre>

<p>  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:</p>

<pre class="code">    375.104545883 (  real) -&gt;   10.341x 
      0.002665923
</pre>

<p>  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:</p>

<pre class="code">     49.978706968 (  real) -&gt;    1.378x 
      0.020008521
</pre>

<p>  5 GeneratorBenchmarkRails#generator       1000 repeats:</p>

<pre class="code">     38.531868759 (  real) -&gt;    1.062x 
      0.025952543
</pre>

<p>  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:</p>

<pre class="code">     36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
      0.027079979
</pre>

<p>  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:</p>

<pre class="code">     36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
      0.027569373
        calls/sec (  time) -&gt;    speed  covers
        secs/call
</pre>

<p>In the table above 1-3 are JSON::Ext::Generator methods. 4, 6, and 7 are
JSON::Pure::Generator methods and 5 is the Rails JSON generator. It is now a
bit faster than the generator<em>safe and generator</em>pretty methods of the pure
variant but slower than the others.</p>

<p>To achieve the fastest JSON document output, you can use the fast_generate
method. Beware, that this will disable the checking for circular Ruby data
structures, which may cause JSON to go into an infinite loop.</p>

<p>Here are the median comparisons for completeness' sake:</p>

<p> Comparing times (call<em>time</em>median):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:</p>

<pre class="code">    708.258020939 (  real) -&gt;   16.547x 
      0.001411915
</pre>

<p>  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:</p>

<pre class="code">    569.105020353 (  real) -&gt;   13.296x 
      0.001757145
</pre>

<p>  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:</p>

<pre class="code">    482.825371244 (  real) -&gt;   11.280x 
      0.002071142
</pre>

<p>  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:</p>

<pre class="code">     62.717626652 (  real) -&gt;    1.465x 
      0.015944481
</pre>

<p>  5 GeneratorBenchmarkRails#generator       1000 repeats:</p>

<pre class="code">     43.965681162 (  real) -&gt;    1.027x 
      0.022745013
</pre>

<p>  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:</p>

<pre class="code">     43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
      0.022763968
</pre>

<p>  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:</p>

<pre class="code">     42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
      0.023363113
        calls/sec (  time) -&gt;    speed  covers
        secs/call
</pre>

<p>== Author</p>

<p>Florian Frank <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#102;&#x6c;&#x6f;&#114;&#x69;&#64;&#x70;&#x69;&#110;&#103;&#46;&#100;&#101;">&#x66;&#108;&#x6f;&#x72;&#105;&#64;&#112;&#x69;&#x6e;&#x67;&#x2e;&#100;&#101;</a></p>

<p>== License</p>

<p>Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so see
the file GPL as well.</p>

<p>== Download</p>

<p>The latest version of this library can be downloaded at</p>

<ul>
<li>http://rubyforge.org/frs?group_id=953</li>
</ul>


<p>Online Documentation should be located at</p>

<ul>
<li>http://json.rubyforge.org</li>
</ul>
</div></div>
    
    <div id="footer">
  Generated on Mon Aug 22 16:49:22 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.2 (ruby-1.9.2).
</div>

  </body>
</html>