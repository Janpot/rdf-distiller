<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  File: builder-README
  
    &mdash; Web portal for RDF.rb.
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: builder-README</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><p>= Project: Builder</p>

<p>== Goal</p>

<p>Provide a simple way to create XML markup and data structures.</p>

<p>== Classes</p>

<p>Builder::XmlMarkup:: Generate XML markup notiation
Builder::XmlEvents:: Generate XML events (i.e. SAX-like)</p>

<p><b>Notes</b>::</p>

<ul>
<li>An <tt>Builder::XmlTree</tt> class to generate XML tree
(i.e. DOM-like) structures is also planned, but not yet implemented.
Also, the events builder is currently lagging the markup builder in
features.</li>
</ul>


<p>== Usage</p>

<p>  require 'rubygems'  <br/>
  require_gem 'builder', '~> 3.0'</p>

<p>  builder = Builder::XmlMarkup.new
  xml = builder.person { |b| b.name("Jim"); b.phone("555-1234") }
  xml #=> <person><name>Jim</name><phone>555-1234</phone></person></p>

<p>or</p>

<p>  require 'rubygems'  <br/>
  require_gem 'builder'</p>

<p>  builder = Builder::XmlMarkup.new(:target=>STDOUT, :indent=>2)
  builder.person { |b| b.name("Jim"); b.phone("555-1234") }
  #
  # Prints:
  # <person>
  #   <name>Jim</name>
  #   <phone>555-1234</phone>
  # </person></p>

<p>== Compatibility</p>

<p>=== Version 3.0.0</p>

<p>Version 3 adds Ruby 1.9.2 compatibility.</p>

<p>=== Version 2.0.0 Compatibility Changes</p>

<p>Version 2.0.0 introduces automatically escaped attribute values for
the first time.  Versions prior to 2.0.0 did not insert escape
characters into attribute values in the XML markup.  This allowed
attribute values to explicitly reference entities, which was
occasionally used by a small number of developers.  Since strings
could always be explicitly escaped by hand, this was not a major
restriction in functionality.</p>

<p>However, it did suprise most users of builder.  Since the body text is
normally escaped, everybody expected the attribute values to be
escaped as well.  Escaped attribute values were the number one support
request on the 1.x Builder series.</p>

<p>Starting with Builder version 2.0.0, all attribute values expressed as
strings will be processed and the appropriate characters will be
escaped (e.g. "&amp;" will be tranlated to "&amp;").  Attribute values
that are expressed as Symbol values will not be processed for escaped
characters and will be unchanged in output. (Yes, this probably counts
as Symbol abuse, but the convention is convenient and flexible).</p>

<p>Example:</p>

<p>  xml = Builder::XmlMarkup.new
  xml.sample(:escaped=>"This&amp;That", :unescaped=>:"Here&amp;There")
  xml.target!  =></p>

<pre class="code"><span class='lt op'>&lt;</span><span class='sample identifier id'>sample</span> <span class='escaped identifier id'>escaped</span><span class='assign token'>=</span><span class='string val'>&quot;This&amp;amp;That&quot;</span> <span class='unescaped identifier id'>unescaped</span><span class='assign token'>=</span><span class='string val'>&quot;Here&amp;amp;There&quot;</span><span class='div op'>/</span><span class='gt op'>&gt;</span>
</pre>

<p>=== Version 1.0.0 Compatibility Changes</p>

<p>Version 1.0.0 introduces some changes that are not backwards
compatible with earlier releases of builder.  The main areas of
incompatibility are:</p>

<ul>
<li><p>Keyword based arguments to +new+ (rather than positional based).  It
was found that a developer would often like to specify indentation
without providing an explicit target, or specify a target without
indentation.  Keyword based arguments handle this situation nicely.</p></li>
<li><p>Builder must now be an explicit target for markup tags.  Instead of
writing</p>

<p>  xml<em>markup = Builder::XmlMarkup.new
  xml</em>markup.div { strong("text") }</p>

<p>you need to write</p>

<p>  xml<em>markup = Builder::XmlMarkup.new
  xml</em>markup.div { xml_markup.strong("text") }</p></li>
<li><p>The builder object is passed as a parameter to all nested markup
blocks.  This allows you to create a short alias for the builder
object that can be used within the block.  For example, the previous
example can be written as:</p>

<p>  xml<em>markup = Builder::XmlMarkup.new
  xml</em>markup.div { |xml| xml.strong("text") }</p></li>
<li><p>If you have both a pre-1.0 and a post-1.0 gem of builder installed,
you can choose which version to use through the RubyGems
+require_gem+ facility.</p>

<p>  require<em>gem 'builder', "~> 0.0"   # Gets the old version
  require</em>gem 'builder', "~> 1.0"   # Gets the new version</p></li>
</ul>


<p>== Features</p>

<ul>
<li><p>XML Comments are supported ...</p>

<p>  xml_markup.comment! "This is a comment"
    #=>  <!-- This is a comment --></p></li>
<li><p>XML processing instructions are supported ...</p>

<p>  xml_markup.instruct! :xml, :version=>"1.0", :encoding=>"UTF-8"
    #=>  &lt;?xml version="1.0" encoding="UTF-8"?></p>

<p>If the processing instruction is omitted, it defaults to "xml".
When the processing instruction is "xml", the defaults attributes
are:</p>

<p><b>version</b>:: 1.0
<b>encoding</b>:: "UTF-8"</p>

<p>(NOTE: if the encoding is set to "UTF-8" and $KCODE is set to
"UTF8", then Builder will emit UTF-8 encoded strings rather than
encoding non-ASCII characters as entities.)</p></li>
<li><p>XML entity declarations are now supported to a small degree.</p>

<p>  xml_markup.declare! :DOCTYPE, :chapter, :SYSTEM, "../dtds/chapter.dtd"
    #=>  &lt;!DOCTYPE chapter SYSTEM "../dtds/chapter.dtd"></p>

<p>The parameters to a declare! method must be either symbols or
strings. Symbols are inserted without quotes, and strings are
inserted with double quotes.  Attribute-like arguments in hashes are
not allowed.</p>

<p>If you need to have an argument to declare! be inserted without
quotes, but the arguement does not conform to the typical Ruby
syntax for symbols, then use the :"string" form to specify a symbol.</p>

<p>For example:</p>

<p>  xml_markup.declare! :ELEMENT, :chapter, :"(title,para+)"
    #=>  &lt;!ELEMENT chapter (title,para+)></p>

<p>Nested entity declarations are allowed.  For example:</p>

<p>  @xml_markup.declare! :DOCTYPE, :chapter do |x|
    x.declare! :ELEMENT, :chapter, :"(title,para+)"
    x.declare! :ELEMENT, :title, :"(#PCDATA)"
    x.declare! :ELEMENT, :para, :"(#PCDATA)"
  end</p>

<p>  #=></p>

<p>  &lt;!DOCTYPE chapter [
    &lt;!ELEMENT chapter (title,para+)>
    &lt;!ELEMENT title (#PCDATA)>
    &lt;!ELEMENT para (#PCDATA)>
  ]></p></li>
<li><p>Some support for XML namespaces is now available.  If the first
argument to a tag call is a symbol, it will be joined to the tag to
produce a namespace:tag combination.  It is easier to show this than
describe it.</p>

<p> xml.SOAP :Envelope do ... end</p>

<p>Just put a space before the colon in a namespace to produce the
right form for builder (e.g. "<tt>SOAP:Envelope</tt>" =>
"<tt>xml.SOAP :Envelope</tt>")</p></li>
<li><p>String attribute values are <em>now</em> escaped by default by
Builder (<b>NOTE:</b> this is <em>new</em> behavior as of version 2.0).</p>

<p>However, occasionally you need to use entities in attribute values.
Using a symbols (rather than a string) for an attribute value will
cause Builder to not run its quoting/escaping algorithm on that
particular value.</p>

<p>(<b>Note:</b> The +escape_attrs+ option for builder is now
obsolete).</p>

<p>Example:</p>

<p>  xml = Builder::XmlMarkup.new
  xml.sample(:escaped=>"This&amp;That", :unescaped=>:"Here&amp;There")
  xml.target!  =>
    <sample escaped="This&amp;That" unescaped="Here&amp;There"/></p></li>
<li><p>UTF-8 Support</p>

<p>Builder correctly translates UTF-8 characters into valid XML.  (New
in version 2.0.0).  Thanks to Sam Ruby for the translation code.</p>

<p>Example:</p>

<p>  xml = Builder::Markup.new
  xml.sample("Iñtërnâtiônàl")
  xml.target!  =>
    "<sample>I&#241;t&#235;rn&#226;ti&#244;n&#224;l</sample>"</p>

<p>You can get UTF-8 encoded output by making sure that the XML
encoding is set to "UTF-8" and that the $KCODE variable is set to
"UTF8".</p>

<p>  $KCODE = 'UTF8'
  xml = Builder::Markup.new
  xml.instruct!(:xml, :encoding => "UTF-8")
  xml.sample("Iñtërnâtiônàl")
  xml.target!  =>
    "<sample>Iñtërnâtiônàl</sample>"</p></li>
</ul>


<p>== Contact</p>

<p>Author::     Jim Weirich
Email::      jim@weirichhouse.org
Home Page::  http://onestepback.org
License::    MIT Licence (http://www.opensource.org/licenses/mit-license.html)</p></div></div>
    
    <div id="footer">
  Generated on Fri Nov 18 17:41:35 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.3 (ruby-1.8.7).
</div>

  </body>
</html>