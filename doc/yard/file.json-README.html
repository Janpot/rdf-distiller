<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  File: json-README
  
    &mdash; Web portal for RDF.rb.
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: json-README</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><p>== Description</p>

<p>This is a implementation of the JSON specification according to RFC 4627
http://www.ietf.org/rfc/rfc4627.txt . Starting from version 1.0.0 on there
will be two variants available:</p>

<ul>
<li>A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.</li>
<li>The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler
http://www.cs.queensu.ca/~thurston/ragel .</li>
</ul>


<p>Both variants of the JSON generator generate UTF-8 character sequences by
default. If an :ascii_only option with a true value is given, they escape all
non-ASCII and control characters with \uXXXX escape sequences, and support
UTF-16 surrogate pairs in order to be able to generate the whole range of
unicode code points.</p>

<p>All strings, that are to be encoded as JSON strings, should be UTF-8 byte
sequences on the Ruby side. To encode raw binary strings, that aren't UTF-8
encoded, please use the to<em>json</em>raw_object method of String (which produces
an object, that contains a byte array) and decode the result on the receiving
endpoint.</p>

<p>The JSON parsers can parse UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE
JSON documents under Ruby 1.8. Under Ruby 1.9 they take advantage of Ruby's
M17n features and can parse all documents which have the correct
String#encoding set. If a document string has ASCII-8BIT as an encoding the
parser attempts to figure out which of the UTF encodings from above it is and
trys to parse it.</p>

<p>== Installation</p>

<p>It's recommended to use the extension variant of JSON, because it's faster than
the pure ruby variant. If you cannot build it on your system, you can settle
for the latter.</p>

<p>Just type into the command line as root:</p>

<p>  # rake install</p>

<p>The above command will build the extensions and install them on your system.</p>

<p>  # rake install_pure</p>

<p>or</p>

<p>  # ruby install.rb</p>

<p>will just install the pure ruby implementation of JSON.</p>

<p>If you use Rubygems you can type</p>

<p>  # gem install json</p>

<p>instead, to install the newest JSON version.</p>

<p>There is also a pure ruby json only variant of the gem, that can be installed
with:</p>

<p>  # gem install json_pure</p>

<p>== Compiling the extensions yourself</p>

<p>If you want to build the extensions yourself you need rake:</p>

<p>  You can get it from rubyforge:</p>

<pre class="code"><span class='http identifier id'>http</span><span class='symbol val'>:/</span><span class='regexp val'>/rubyforge.org/</span><span class='projects identifier id'>projects</span><span class='div op'>/</span><span class='rake identifier id'>rake</span>
</pre>

<p>  or just type</p>

<p>  # gem install rake</p>

<p>  for the installation via rubygems.</p>

<p>If you want to create the parser.c file from its parser.rl file or draw nice
graphviz images of the state machines, you need ragel from: http://www.cs.queensu.ca/~thurston/ragel</p>

<p>== Usage</p>

<p>To use JSON you can
  require 'json'
to load the installed variant (either the extension 'json' or the pure
variant 'json_pure'). If you have installed the extension variant, you can
pick either the extension variant or the pure variant by typing
  require 'json/ext'
or
  require 'json/pure'</p>

<p>Now you can parse a JSON document into a ruby data structure by calling</p>

<p>  JSON.parse(document)</p>

<p>If you want to generate a JSON document from a ruby data structure call
  JSON.generate(data)</p>

<p>You can also use the pretty<em>generate method (which formats the output more
verbosely and nicely) or fast</em>generate (which doesn't do any of the security
checks generate performs, e. g. nesting deepness checks).</p>

<p>To create a valid JSON document you have to make sure, that the output is
embedded in either a JSON array [] or a JSON object {}. The easiest way to do
this, is by putting your values in a Ruby Array or Hash instance.</p>

<p>There are also the JSON and JSON[] methods which use parse on a String or
generate a JSON document from an array or hash:</p>

<p>  document = JSON 'test'  => 23 # => "\&quot;test\&quot;:23"
  document = JSON['test'] => 23 # => "\&quot;test\&quot;:23"</p>

<p>and</p>

<p>  data = JSON '&quot;test&quot;:23'  # => &quot;test&quot;=&gt;23
  data = JSON['&quot;test&quot;:23'] # => &quot;test&quot;=&gt;23</p>

<p>You can choose to load a set of common additions to ruby core's objects if
you
  require 'json/add/core'</p>

<p>After requiring this you can, e. g., serialise/deserialise Ruby ranges:</p>

<p>  JSON JSON(1..10) # => 1..10</p>

<p>To find out how to add JSON support to other or your own classes, read the
section "More Examples" below.</p>

<p>To get the best compatibility to rails' JSON implementation, you can
  require 'json/add/rails'</p>

<p>Both of the additions attempt to require 'json' (like above) first, if it has
not been required yet.</p>

<p>== More Examples</p>

<p>To create a JSON document from a ruby data structure, you can call
JSON.generate like that:</p>

<p> json = JSON.generate [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]
 # => "[1,2,\&quot;a\&quot;:3\&quot;a\&quot;:3.141,false,true,null,\"4..10\"]"</p>

<p>To get back a ruby data structure from a JSON document, you have to call
JSON.parse on it:</p>

<p> JSON.parse json
 # => [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, "4..10"]</p>

<p>Note, that the range from the original data structure is a simple
string now. The reason for this is, that JSON doesn't support ranges
or arbitrary classes. In this case the json library falls back to call
Object#to<em>json, which is the same as #to</em>s.to_json.</p>

<p>It's possible to add JSON support serialization to arbitrary classes by
simply implementing a more specialized version of the #to<em>json method, that
should return a JSON object (a hash converted to JSON with #to</em>json) like
this (don't forget the *a for all the arguments):</p>

<p> class Range
   def to_json(*a)</p>

<pre class="code"> <span class='lbrace token'>{</span>
   <span class='string val'>'json_class'</span>   <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='class identifier id'>class</span><span class='dot token'>.</span><span class='name identifier id'>name</span><span class='comma token'>,</span> <span class='comment val'># = 'Range'</span>
   <span class='string val'>'data'</span>         <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span> <span class='first identifier id'>first</span><span class='comma token'>,</span> <span class='last identifier id'>last</span><span class='comma token'>,</span> <span class='exclude_end? fid id'>exclude_end?</span> <span class='rbrack token'>]</span>
 <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='to_json identifier id'>to_json</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='a identifier id'>a</span><span class='rparen token'>)</span>
</pre>

<p>   end
 end</p>

<p>The hash key 'json_class' is the class, that will be asked to deserialise the
JSON representation later. In this case it's 'Range', but any namespace of
the form 'A::B' or '::A::B' will do. All other keys are arbitrary and can be
used to store the necessary data to configure the object to be deserialised.</p>

<p>If a the key 'json<em>class' is found in a JSON object, the JSON parser checks
if the given class responds to the json</em>create class method. If so, it is
called with the JSON object converted to a Ruby hash. So a range can
be deserialised by implementing Range.json_create like this:</p>

<p> class Range
   def self.json_create(o)</p>

<pre class="code"> <span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='o identifier id'>o</span><span class='lbrack token'>[</span><span class='string val'>'data'</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
</pre>

<p>   end
 end</p>

<p>Now it possible to serialise/deserialise ranges as well:</p>

<p> json = JSON.generate [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]
 # => "[1,2,\&quot;a\&quot;:3\&quot;a\&quot;:3.141,false,true,null,\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]]"
 JSON.parse json
 # => [1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10]</p>

<p>JSON.generate always creates the shortest possible string representation of a
ruby data structure in one line. This is good for data storage or network
protocols, but not so good for humans to read. Fortunately there's also
JSON.pretty<em>generate (or JSON.pretty</em>generate) that creates a more readable
output:</p>

<p> puts JSON.pretty_generate([1, 2, &quot;a&quot;=&gt;3&quot;a&quot;=&gt;3.141, false, true, nil, 4..10])
 [
   1,
   2,
   {</p>

<pre class="code"> <span class='string val'>&quot;a&quot;</span><span class='colon op'>:</span> <span class='float val'>3.141</span>
</pre>

<p>   },
   false,
   true,
   null,
   {</p>

<pre class="code"> <span class='string val'>&quot;json_class&quot;</span><span class='colon op'>:</span> <span class='string val'>&quot;Range&quot;</span><span class='comma token'>,</span>
 <span class='string val'>&quot;data&quot;</span><span class='colon op'>:</span> <span class='lbrack token'>[</span>
   <span class='integer val'>4</span><span class='comma token'>,</span>
   <span class='integer val'>10</span><span class='comma token'>,</span>
   <span class='false false kw'>false</span>
 <span class='rbrack token'>]</span>
</pre>

<p>   }
 ]</p>

<p>There are also the methods Kernel#j for generate, and Kernel#jj for
pretty_generate output to the console, that work analogous to Core Ruby's p and
the pp library's pp methods.</p>

<p>The script tools/server.rb contains a small example if you want to test, how
receiving a JSON object from a webrick server in your browser with the
javasript prototype library http://www.prototypejs.org works.</p>

<p>== Speed Comparisons</p>

<p>I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the JSON-parser to estimate the speed up in the C
extension:</p>

<p> Comparing times (call<em>time</em>mean):
  1 ParserBenchmarkExt#parser   900 repeats:</p>

<pre class="code">    <span class='float val'>553.922304770</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>21.500</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.001805307</span>
</pre>

<p>  2 ParserBenchmarkYAML#parser  1000 repeats:</p>

<pre class="code">    <span class='float val'>224.513358139</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>8.714</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.004454078</span>
</pre>

<p>  3 ParserBenchmarkPure#parser  1000 repeats:</p>

<pre class="code">     <span class='float val'>26.755020642</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.038</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.037376163</span>
</pre>

<p>  4 ParserBenchmarkRails#parser 1000 repeats:</p>

<pre class="code">     <span class='float val'>25.763381731</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.000</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.038814780</span>
        <span class='calls identifier id'>calls</span><span class='div op'>/</span><span class='sec identifier id'>sec</span> <span class='lparen token'>(</span>  <span class='time identifier id'>time</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='speed identifier id'>speed</span>  <span class='covers identifier id'>covers</span>
        <span class='secs identifier id'>secs</span><span class='div op'>/</span><span class='call identifier id'>call</span>
</pre>

<p>In the table above 1 is JSON::Ext::Parser, 2 is YAML.load with YAML
compatbile JSON document, 3 is is JSON::Pure::Parser, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport JSON-decoder converts the
input first to YAML and then uses the YAML-parser, the conversion seems to
slow it down so much that it is only as fast as the JSON::Pure::Parser!</p>

<p>If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the JSON::Pure::Parser runs:</p>

<p> Comparing times (call<em>time</em>median):
  1 ParserBenchmarkExt#parser   900 repeats:</p>

<pre class="code">    <span class='float val'>800.592479481</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>26.936</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.001249075</span>
</pre>

<p>  2 ParserBenchmarkYAML#parser  1000 repeats:</p>

<pre class="code">    <span class='float val'>271.002390644</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>9.118</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.003690004</span>
</pre>

<p>  3 ParserBenchmarkRails#parser 1000 repeats:</p>

<pre class="code">     <span class='float val'>30.227910865</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.017</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.033082008</span>
</pre>

<p>  4 ParserBenchmarkPure#parser  1000 repeats:</p>

<pre class="code">     <span class='float val'>29.722384421</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.000</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.033644676</span>
        <span class='calls identifier id'>calls</span><span class='div op'>/</span><span class='sec identifier id'>sec</span> <span class='lparen token'>(</span>  <span class='time identifier id'>time</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='speed identifier id'>speed</span>  <span class='covers identifier id'>covers</span>
        <span class='secs identifier id'>secs</span><span class='div op'>/</span><span class='call identifier id'>call</span>
</pre>

<p>I have benchmarked the JSON-Generator as well. This generated a few more
values, because there are different modes that also influence the achieved
speed:</p>

<p> Comparing times (call<em>time</em>mean):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:</p>

<pre class="code">    <span class='float val'>547.354332608</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>15.090</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.001826970</span>
</pre>

<p>  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:</p>

<pre class="code">    <span class='float val'>443.968212317</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>12.240</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.002252414</span>
</pre>

<p>  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:</p>

<pre class="code">    <span class='float val'>375.104545883</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>10.341</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.002665923</span>
</pre>

<p>  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:</p>

<pre class="code">     <span class='float val'>49.978706968</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.378</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.020008521</span>
</pre>

<p>  5 GeneratorBenchmarkRails#generator       1000 repeats:</p>

<pre class="code">     <span class='float val'>38.531868759</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.062</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.025952543</span>
</pre>

<p>  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:</p>

<pre class="code">     <span class='float val'>36.927649925</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.018</span><span class='x identifier id'>x</span> <span class='integer val'>7</span> <span class='lparen token'>(</span><span class='geq op'>&gt;=</span><span class='integer val'>3859</span><span class='rparen token'>)</span>
      <span class='integer val'>0</span><span class='integer val'>.027079979</span>
</pre>

<p>  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:</p>

<pre class="code">     <span class='float val'>36.272134441</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.000</span><span class='x identifier id'>x</span> <span class='integer val'>6</span> <span class='lparen token'>(</span><span class='geq op'>&gt;=</span><span class='integer val'>3859</span><span class='rparen token'>)</span>
      <span class='integer val'>0</span><span class='integer val'>.027569373</span>
        <span class='calls identifier id'>calls</span><span class='div op'>/</span><span class='sec identifier id'>sec</span> <span class='lparen token'>(</span>  <span class='time identifier id'>time</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='speed identifier id'>speed</span>  <span class='covers identifier id'>covers</span>
        <span class='secs identifier id'>secs</span><span class='div op'>/</span><span class='call identifier id'>call</span>
</pre>

<p>In the table above 1-3 are JSON::Ext::Generator methods. 4, 6, and 7 are
JSON::Pure::Generator methods and 5 is the Rails JSON generator. It is now a
bit faster than the generator<em>safe and generator</em>pretty methods of the pure
variant but slower than the others.</p>

<p>To achieve the fastest JSON document output, you can use the fast_generate
method. Beware, that this will disable the checking for circular Ruby data
structures, which may cause JSON to go into an infinite loop.</p>

<p>Here are the median comparisons for completeness' sake:</p>

<p> Comparing times (call<em>time</em>median):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:</p>

<pre class="code">    <span class='float val'>708.258020939</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>16.547</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.001411915</span>
</pre>

<p>  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:</p>

<pre class="code">    <span class='float val'>569.105020353</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>13.296</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.001757145</span>
</pre>

<p>  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:</p>

<pre class="code">    <span class='float val'>482.825371244</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>   <span class='float val'>11.280</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.002071142</span>
</pre>

<p>  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:</p>

<pre class="code">     <span class='float val'>62.717626652</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.465</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.015944481</span>
</pre>

<p>  5 GeneratorBenchmarkRails#generator       1000 repeats:</p>

<pre class="code">     <span class='float val'>43.965681162</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.027</span><span class='x identifier id'>x</span> 
      <span class='integer val'>0</span><span class='integer val'>.022745013</span>
</pre>

<p>  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:</p>

<pre class="code">     <span class='float val'>43.929073409</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.026</span><span class='x identifier id'>x</span> <span class='integer val'>7</span> <span class='lparen token'>(</span><span class='geq op'>&gt;=</span><span class='integer val'>3859</span><span class='rparen token'>)</span>
      <span class='integer val'>0</span><span class='integer val'>.022763968</span>
</pre>

<p>  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:</p>

<pre class="code">     <span class='float val'>42.802514491</span> <span class='lparen token'>(</span>  <span class='real identifier id'>real</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='float val'>1.000</span><span class='x identifier id'>x</span> <span class='integer val'>6</span> <span class='lparen token'>(</span><span class='geq op'>&gt;=</span><span class='integer val'>3859</span><span class='rparen token'>)</span>
      <span class='integer val'>0</span><span class='integer val'>.023363113</span>
        <span class='calls identifier id'>calls</span><span class='div op'>/</span><span class='sec identifier id'>sec</span> <span class='lparen token'>(</span>  <span class='time identifier id'>time</span><span class='rparen token'>)</span> <span class='minus op'>-</span><span class='gt op'>&gt;</span>    <span class='speed identifier id'>speed</span>  <span class='covers identifier id'>covers</span>
        <span class='secs identifier id'>secs</span><span class='div op'>/</span><span class='call identifier id'>call</span>
</pre>

<p>== Author</p>

<p>Florian Frank <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#102;&#x6c;&#x6f;&#114;&#x69;&#64;&#x70;&#x69;&#110;&#103;&#46;&#100;&#101;">&#x66;&#108;&#x6f;&#x72;&#105;&#64;&#112;&#x69;&#x6e;&#x67;&#x2e;&#100;&#101;</a></p>

<p>== License</p>

<p>Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so see
the file GPL as well.</p>

<p>== Download</p>

<p>The latest version of this library can be downloaded at</p>

<ul>
<li>http://rubyforge.org/frs?group_id=953</li>
</ul>


<p>Online Documentation should be located at</p>

<ul>
<li>http://json.rubyforge.org</li>
</ul>
</div></div>
    
    <div id="footer">
  Generated on Wed Jun 29 20:34:47 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.2 (ruby-1.8.7).
</div>

  </body>
</html>