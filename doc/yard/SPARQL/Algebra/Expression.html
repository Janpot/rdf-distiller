<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Module: SPARQL::Algebra::Expression
  
    &mdash; Web portal for RDF.rb.
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '../..';
  if (relpath != '') relpath += '/';
</script>

  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../../_index.html">Index (E)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../../SPARQL.html" title="SPARQL (module)">SPARQL</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Algebra.html" title="SPARQL::Algebra (module)">Algebra</a></span></span>
     &raquo; 
    <span class="title">Expression</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a id="class_list_link" href="#">Class List</a>
  
    <a id="method_list_link" href="#">Method List</a>
  
    <a id="file_list_link" href="#">File List</a>
  
</div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Module: SPARQL::Algebra::Expression
  <span class="abstract note title">Abstract</span>
  
  
</h1>

<dl class="box">
  
  
    
  
    
  
  
    <dt class="r1">Included in:</dt>
    <dd class="r1"><span class='object_link'><a href="../../RDF/Query/Variable.html" title="RDF::Query::Variable (class)">RDF::Query::Variable</a></span>, <span class='object_link'><a href="../../RDF/Term.html" title="RDF::Term (module)">RDF::Term</a></span>, <span class='object_link'><a href="Operator.html" title="SPARQL::Algebra::Operator (class)">Operator</a></span></dd>
    
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb<span class="defines">,<br />
  vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-9862df5abf3b/lib/sparql/algebra/expression.rb,<br /> vendor/bundler/ruby/1.9.1/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <div class="note abstract">
  <strong>This module is abstract.</strong> 
  <div class='inline'></div>
</div>
<p>A SPARQL algebra expression.</p>

  </div>
</div>
<div class="tags">
  
</div>




  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cast-class_method" title="cast (class method)">+ (Boolean) <strong>cast</strong>(datatype, value) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Casts operand as the specified datatype.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#for-class_method" title="for (class method)">+ (Expression) <strong>for</strong>(*sse) </a>
    

    
      (also: [])
    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-class_method" title="new (class method)">+ (Expression) <strong>new</strong>(sse, options = {}) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#open-class_method" title="open (class method)">+ (Expression) <strong>open</strong>(filename, options = {}) {|expression| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Parses input from the given file name or URL.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#parse-class_method" title="parse (class method)">+ (Expression) <strong>parse</strong>(sse, options = {}) {|expression| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#constant%3F-instance_method" title="#constant? (instance method)">- (Boolean) <strong>constant?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns <code>true</code>.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#evaluate-instance_method" title="#evaluate (instance method)">- (Expression) <strong>evaluate</strong>(bindings = {}) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Evaluates this expression using the given variable <code>bindings</code>.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#optimize-instance_method" title="#optimize (instance method)">- (Expression) <strong>optimize</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns an optimized version of this expression.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_sse-instance_method" title="#to_sse (instance method)">- (Array) <strong>to_sse</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the SPARQL S-Expression (SSE) representation of this expression.</p></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#variable%3F-instance_method" title="#variable? (instance method)">- (Boolean) <strong>variable?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns <code>false</code>.</p></div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="cast-class_method">
  
    + (<tt>Boolean</tt>) <strong>cast</strong>(datatype, value) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Casts operand as the specified datatype</p>

  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>datatype</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../RDF/URI.html" title="RDF::URI (class)">RDF::URI</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Datatype to evaluate, one of:
xsd:integer, xsd:decimal xsd:float, xsd:double, xsd:string, xsd:boolean, or xsd:dateTime</p></div>
      
    </li>
  
    <li>
      
        <span class='name'>value</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../RDF/Term.html" title="RDF::Term (module)">RDF::Term</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Value, which should be a typed literal, where the type must be that specified</p></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Raises:</h3>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>TypeError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if datatype is not a URI or value cannot be cast to datatype</p></div>
      
    </li>
  
</ul>

  <h3>See Also:</h3>
  <ul class="see">
    
      <li><a href="http://www.w3.org/TR/rdf-sparql-query/#FunctionMapping" target="_parent" title="http://www.w3.org/TR/rdf-sparql-query/#FunctionMapping">http://www.w3.org/TR/rdf-sparql-query/#FunctionMapping</a></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 136</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='cast identifier id'>cast</span><span class='lparen token'>(</span><span class='datatype identifier id'>datatype</span><span class='comma token'>,</span> <span class='value identifier id'>value</span><span class='rparen token'>)</span>
  <span class='case case kw'>case</span> <span class='datatype identifier id'>datatype</span>
  <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='dateTime identifier id'>dateTime</span>
    <span class='case case kw'>case</span> <span class='value identifier id'>value</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='DateTime constant id'>DateTime</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Date constant id'>Date</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Time constant id'>Time</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='rparen token'>)</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Numeric constant id'>Numeric</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Boolean constant id'>Boolean</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='URI constant id'>URI</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
      <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;Value #{value.inspect} cannot be cast as #{datatype}&quot;</span>
    <span class='else else kw'>else</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='dot token'>.</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='comma token'>,</span> <span class='symbol val'>:validate</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
  <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='float identifier id'>float</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='double identifier id'>double</span>
    <span class='case case kw'>case</span> <span class='value identifier id'>value</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Numeric constant id'>Numeric</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Boolean constant id'>Boolean</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='rparen token'>)</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='DateTime constant id'>DateTime</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Date constant id'>Date</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Time constant id'>Time</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='URI constant id'>URI</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
      <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;Value #{value.inspect} cannot be cast as #{datatype}&quot;</span>
    <span class='else else kw'>else</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='dot token'>.</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='comma token'>,</span> <span class='symbol val'>:validate</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
  <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='boolean identifier id'>boolean</span>
    <span class='case case kw'>case</span> <span class='value identifier id'>value</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Boolean constant id'>Boolean</span>
      <span class='value identifier id'>value</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Numeric constant id'>Numeric</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Boolean constant id'>Boolean</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='dot token'>.</span><span class='value identifier id'>value</span> <span class='neq op'>!=</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='DateTime constant id'>DateTime</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Date constant id'>Date</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Time constant id'>Time</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='URI constant id'>URI</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
      <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;Value #{value.inspect} cannot be cast as #{datatype}&quot;</span>
    <span class='else else kw'>else</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='notop op'>!</span><span class='value identifier id'>value</span><span class='dot token'>.</span><span class='to_s identifier id'>to_s</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='comma token'>,</span> <span class='symbol val'>:validate</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
  <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='decimal identifier id'>decimal</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='integer identifier id'>integer</span>
    <span class='case case kw'>case</span> <span class='value identifier id'>value</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Integer constant id'>Integer</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Decimal constant id'>Decimal</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Boolean constant id'>Boolean</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='rparen token'>)</span>
    <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='DateTime constant id'>DateTime</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Date constant id'>Date</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='colon2 op'>::</span><span class='Time constant id'>Time</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='URI constant id'>URI</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
      <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;Value #{value.inspect} cannot be cast as #{datatype}&quot;</span>
    <span class='else else kw'>else</span>
      <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='dot token'>.</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='comma token'>,</span> <span class='symbol val'>:validate</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
  <span class='when when kw'>when</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='XSD constant id'>XSD</span><span class='dot token'>.</span><span class='string identifier id'>string</span>
     <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='value identifier id'>value</span><span class='comma token'>,</span> <span class='symbol val'>:datatype</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='datatype identifier id'>datatype</span><span class='rparen token'>)</span>
  <span class='else else kw'>else</span>
    <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;Expected datatype (#{datatype}) to be an XSD type&quot;</span>
  <span class='end end kw'>end</span>
<span class='rescue rescue kw'>rescue</span>
  <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='$! gvar id'>$!</span><span class='dot token'>.</span><span class='message identifier id'>message</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="for-class_method">
  
    + (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>for</strong>(*sse) 
  

  
    <span class="aliases">Also known as:
    <span class="names"><span id='[]-class_method'>[]</span></span>
    </span>
  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h3>Examples:</h3>
    
      <h4><div class='inline'></div></h4>
      <pre class="example code"><span class='Expression constant id'>Expression</span><span class='dot token'>.</span><span class='for identifier id'>for</span><span class='lparen token'>(</span><span class='symbol val'>:isLiteral</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='lparen token'>(</span><span class='float val'>3.1415</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
<span class='Expression constant id'>Expression</span><span class='lbrack token'>[</span><span class='symbol val'>:isLiteral</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='lparen token'>(</span><span class='float val'>3.1415</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
</pre>
    
  </div>
<h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>sse</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a SPARQL S-Expression (SSE) form</p></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


72
73
74</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 72</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='for identifier id'>for</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='sse identifier id'>sse</span><span class='rparen token'>)</span>
  <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='sse identifier id'>sse</span><span class='rparen token'>)</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="new-class_method">
  
    + (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>new</strong>(sse, options = {}) 
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h3>Examples:</h3>
    
      <h4><div class='inline'></div></h4>
      <pre class="example code"><span class='Expression constant id'>Expression</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='lbrack token'>[</span><span class='symbol val'>:isLiteral</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='lparen token'>(</span><span class='float val'>3.1415</span><span class='rparen token'>)</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:version</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>1.0</span><span class='rparen token'>)</span>
</pre>
    
  </div>
<h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>sse</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a SPARQL S-Expression (SSE) form</p></div>
      
    </li>
  
    <li>
      
        <span class='name'>options</span>
      
      
        <span class='type'>(<tt>Hash{<span class='object_link'><a href="../../Symbol.html" title="Symbol (class)">Symbol</a></span> =&gt; <span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span>}</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>any additional options (see <span class='object_link'><a href="Operator.html#initialize-instance_method" title="SPARQL::Algebra::Operator#initialize (method)">Operator#initialize</a></span>)</p></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Raises:</h3>
<ul class="raise">
  
    <li>
      
      
        <span class='type'>(<tt>TypeError</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>if any of the operands is invalid</p></div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 87</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='sse identifier id'>sse</span><span class='comma token'>,</span> <span class='options identifier id'>options</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='rparen token'>)</span>
  <span class='raise identifier id'>raise</span> <span class='ArgumentError constant id'>ArgumentError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;invalid SPARQL::Algebra::Expression form: #{sse.inspect}&quot;</span> <span class='unless unless_mod kw'>unless</span> <span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='is_a? fid id'>is_a?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span>

  <span class='operator identifier id'>operator</span> <span class='assign token'>=</span> <span class='Operator constant id'>Operator</span><span class='dot token'>.</span><span class='for identifier id'>for</span><span class='lparen token'>(</span><span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='comma token'>,</span> <span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='minus op'>-</span> <span class='integer val'>1</span><span class='rparen token'>)</span>
  <span class='unless unless kw'>unless</span> <span class='operator identifier id'>operator</span>
    <span class='return return kw'>return</span> <span class='case case kw'>case</span> <span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
    <span class='when when kw'>when</span> <span class='Array constant id'>Array</span>
      <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='dstring node'>&quot;Map array elements #{sse}&quot;</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
      <span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='map identifier id'>map</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='s identifier id'>s</span><span class='bitor op'>|</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='s identifier id'>s</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='symbol val'>:depth</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:depth</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span> <span class='plus op'>+</span> <span class='integer val'>1</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='rbrace token'>}</span>
    <span class='else else kw'>else</span>
      <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='dstring node'>&quot;No operator found for #{sse.first}&quot;</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
      <span class='sse identifier id'>sse</span><span class='dot token'>.</span><span class='map identifier id'>map</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='s identifier id'>s</span><span class='bitor op'>|</span>
        <span class='s identifier id'>s</span><span class='dot token'>.</span><span class='is_a? fid id'>is_a?</span><span class='lparen token'>(</span><span class='Array constant id'>Array</span><span class='rparen token'>)</span> <span class='question op'>?</span>
          <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='s identifier id'>s</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='symbol val'>:depth</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:depth</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span> <span class='plus op'>+</span> <span class='integer val'>1</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='colon op'>:</span>
          <span class='s identifier id'>s</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>

  <span class='operands identifier id'>operands</span> <span class='assign token'>=</span> <span class='sse identifier id'>sse</span><span class='lbrack token'>[</span><span class='float val'>1</span><span class='dot2 op'>..</span><span class='integer val'>-1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='map identifier id'>map</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='operand identifier id'>operand</span><span class='bitor op'>|</span>
    <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='dstring node'>&quot;Operator=#{operator.inspect}, Operand=#{operand.inspect}&quot;</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
    <span class='case case kw'>case</span> <span class='operand identifier id'>operand</span>
      <span class='when when kw'>when</span> <span class='Array constant id'>Array</span>
        <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='operand identifier id'>operand</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='symbol val'>:depth</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:depth</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span> <span class='plus op'>+</span> <span class='integer val'>1</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
      <span class='when when kw'>when</span> <span class='Operator constant id'>Operator</span><span class='comma token'>,</span> <span class='Variable constant id'>Variable</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Term constant id'>Term</span><span class='comma token'>,</span> <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Query constant id'>Query</span><span class='comma token'>,</span> <span class='Symbol constant id'>Symbol</span>
        <span class='operand identifier id'>operand</span>
      <span class='when when kw'>when</span> <span class='TrueClass constant id'>TrueClass</span><span class='comma token'>,</span> <span class='FalseClass constant id'>FalseClass</span><span class='comma token'>,</span> <span class='Numeric constant id'>Numeric</span><span class='comma token'>,</span> <span class='String constant id'>String</span><span class='comma token'>,</span> <span class='DateTime constant id'>DateTime</span><span class='comma token'>,</span> <span class='Date constant id'>Date</span><span class='comma token'>,</span> <span class='Time constant id'>Time</span>
        <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Literal constant id'>Literal</span><span class='lparen token'>(</span><span class='operand identifier id'>operand</span><span class='rparen token'>)</span>
      <span class='else else kw'>else</span> <span class='raise identifier id'>raise</span> <span class='TypeError constant id'>TypeError</span><span class='comma token'>,</span> <span class='dstring node'>&quot;invalid SPARQL::Algebra::Expression operand: #{operand.inspect}&quot;</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>

  <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='dstring node'>&quot;#{operator.inspect}(#{operands.map(&amp;:inspect).join(',')})&quot;</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
  <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='delete_if identifier id'>delete_if</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='k identifier id'>k</span><span class='comma token'>,</span> <span class='v identifier id'>v</span><span class='bitor op'>|</span> <span class='lbrack token'>[</span><span class='symbol val'>:debug</span><span class='comma token'>,</span> <span class='symbol val'>:depth</span><span class='comma token'>,</span> <span class='symbol val'>:prefixes</span><span class='comma token'>,</span> <span class='symbol val'>:base_uri</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='k identifier id'>k</span><span class='rparen token'>)</span> <span class='rbrace token'>}</span>
  <span class='operands identifier id'>operands</span> <span class='lshft op'>&lt;&lt;</span> <span class='options identifier id'>options</span> <span class='unless unless_mod kw'>unless</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span>
  <span class='operator identifier id'>operator</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='mult op'>*</span><span class='operands identifier id'>operands</span><span class='rparen token'>)</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="open-class_method">
  
    + (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>open</strong>(filename, options = {}) {|expression| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Parses input from the given file name or URL.</p>

  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>filename</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../String.html" title="String (class)">String</a></span></tt>, <tt>#to_s</tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>options</span>
      
      
        <span class='type'>(<tt>Hash{<span class='object_link'><a href="../../Symbol.html" title="Symbol (class)">Symbol</a></span> =&gt; <span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span>}</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>any additional options (see <span class='object_link'><a href="Operator.html#initialize-instance_method" title="SPARQL::Algebra::Operator#initialize (method)">Operator#initialize</a></span>)</p></div>
      
    </li>
  
</ul>

  
    
    
    
    
    <h3>Options Hash (<tt>options</tt>):</h3>
    <ul class="option">
      
        <li>
          <span class="name">:base_uri</span>
          <span class="type">(<tt><span class='object_link'><a href="../../RDF/URI.html" title="RDF::URI (class)">RDF::URI</a></span></tt>, <tt>#to_s</tt>)</span>
          <span class="default">
            
          </span>
          &mdash; <div class='inline'><p>Base URI used for loading relative URIs.</p></div>
        </tr>
      
    </ul>
  
<h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
      
        <span class='type'>(<tt>expression</tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Yield Parameters:</h3>
<ul class="yieldparam">
  
    <li>
      
        <span class='name'>expression</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">SPARQL::Algebra::Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Yield Returns:</h3>
<ul class="yieldreturn">
  
    <li>
      
      
        <span class='type'>(<tt>void</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>ignored</p></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


55
56
57
58
59
60
61
62</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 55</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='open identifier id'>open</span><span class='lparen token'>(</span><span class='filename identifier id'>filename</span><span class='comma token'>,</span> <span class='options identifier id'>options</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='block identifier id'>block</span><span class='rparen token'>)</span>
  <span class='RDF constant id'>RDF</span><span class='colon2 op'>::</span><span class='Util constant id'>Util</span><span class='colon2 op'>::</span><span class='File constant id'>File</span><span class='dot token'>.</span><span class='open_file identifier id'>open_file</span><span class='lparen token'>(</span><span class='filename identifier id'>filename</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='file identifier id'>file</span><span class='bitor op'>|</span>
    <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:base_uri</span><span class='rbrack token'>]</span> <span class='opasgn op'>||=</span> <span class='filename identifier id'>filename</span>
    <span class='expression identifier id'>expression</span> <span class='assign token'>=</span> <span class='Expression constant id'>Expression</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='file identifier id'>file</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>
    <span class='yield yield kw'>yield</span><span class='lparen token'>(</span><span class='expression identifier id'>expression</span><span class='rparen token'>)</span> <span class='if if_mod kw'>if</span> <span class='block_given? fid id'>block_given?</span>
    <span class='expression identifier id'>expression</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="parse-class_method">
  
    + (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>parse</strong>(sse, options = {}) {|expression| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
  <div class="examples">
    <h3>Examples:</h3>
    
      <h4><div class='inline'></div></h4>
      <pre class="example code"><span class='Expression constant id'>Expression</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'(isLiteral 3.1415)'</span><span class='rparen token'>)</span>
</pre>
    
  </div>
<h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>sse</span>
      
      
        <span class='type'>(<tt>IO</tt>, <tt><span class='object_link'><a href="../../String.html" title="String (class)">String</a></span></tt>, <tt>#read</tt>, <tt>#to_s</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>a SPARQL S-Expression (SSE) string or IO object responding to #read</p></div>
      
    </li>
  
    <li>
      
        <span class='name'>options</span>
      
      
        <span class='type'>(<tt>Hash{<span class='object_link'><a href="../../Symbol.html" title="Symbol (class)">Symbol</a></span> =&gt; <span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span>}</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>any additional options (see <span class='object_link'><a href="Operator.html#initialize-instance_method" title="SPARQL::Algebra::Operator#initialize (method)">Operator#initialize</a></span>)</p></div>
      
    </li>
  
</ul>

  
    
    
    
    
    <h3>Options Hash (<tt>options</tt>):</h3>
    <ul class="option">
      
        <li>
          <span class="name">:base_uri</span>
          <span class="type">(<tt><span class='object_link'><a href="../../RDF/URI.html" title="RDF::URI (class)">RDF::URI</a></span></tt>, <tt>#to_s</tt>)</span>
          <span class="default">
            
          </span>
          &mdash; <div class='inline'><p>Base URI used for loading relative URIs.</p></div>
        </tr>
      
    </ul>
  
<h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
      
        <span class='type'>(<tt>expression</tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Yield Parameters:</h3>
<ul class="yieldparam">
  
    <li>
      
        <span class='name'>expression</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">SPARQL::Algebra::Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>
<h3>Yield Returns:</h3>
<ul class="yieldreturn">
  
    <li>
      
      
        <span class='type'>(<tt>void</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>ignored</p></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 22</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='sse identifier id'>sse</span><span class='comma token'>,</span> <span class='options identifier id'>options</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='block identifier id'>block</span><span class='rparen token'>)</span>
  <span class='begin begin kw'>begin</span>
    <span class='require identifier id'>require</span> <span class='string val'>'sxp'</span> <span class='comment val'># @see http://rubygems.org/gems/sxp</span>
  <span class='rescue rescue kw'>rescue</span> <span class='LoadError constant id'>LoadError</span>
    <span class='abort identifier id'>abort</span> <span class='string val'>&quot;SPARQL::Algebra::Expression.parse requires the SXP gem (hint: `gem install sxp').&quot;</span>
  <span class='end end kw'>end</span>
  <span class='require identifier id'>require</span> <span class='string val'>'sparql/algebra/sxp_extensions'</span>
  
  <span class='sxp identifier id'>sxp</span> <span class='assign token'>=</span> <span class='SXP constant id'>SXP</span><span class='colon2 op'>::</span><span class='Reader constant id'>Reader</span><span class='colon2 op'>::</span><span class='SPARQL constant id'>SPARQL</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='sse identifier id'>sse</span><span class='rparen token'>)</span>
  <span class='sxp_result identifier id'>sxp_result</span> <span class='assign token'>=</span> <span class='sxp identifier id'>sxp</span><span class='dot token'>.</span><span class='read identifier id'>read</span>

  <span class='Operator constant id'>Operator</span><span class='dot token'>.</span><span class='base_uri identifier id'>base_uri</span> <span class='assign token'>=</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span><span class='lparen token'>(</span><span class='symbol val'>:base_uri</span><span class='rparen token'>)</span> <span class='if if_mod kw'>if</span> <span class='options identifier id'>options</span><span class='dot token'>.</span><span class='has_key? fid id'>has_key?</span><span class='lparen token'>(</span><span class='symbol val'>:base_uri</span><span class='rparen token'>)</span>
  <span class='Operator constant id'>Operator</span><span class='dot token'>.</span><span class='prefixes identifier id'>prefixes</span> <span class='assign token'>=</span> <span class='sxp identifier id'>sxp</span><span class='dot token'>.</span><span class='prefixes identifier id'>prefixes</span> <span class='orop op'>||</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span>

  <span class='expression identifier id'>expression</span> <span class='assign token'>=</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='sxp_result identifier id'>sxp_result</span><span class='comma token'>,</span> <span class='options identifier id'>options</span><span class='rparen token'>)</span>

  <span class='yield yield kw'>yield</span><span class='lparen token'>(</span><span class='expression identifier id'>expression</span><span class='rparen token'>)</span> <span class='if if_mod kw'>if</span> <span class='block_given? fid id'>block_given?</span>
  <span class='expression identifier id'>expression</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="constant?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>constant?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Returns <code>true</code>.</p>

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p><code>true</code> or <code>false</code></p></div>
      
    </li>
  
</ul>

  <h3>See Also:</h3>
  <ul class="see">
    
      <li><span class='object_link'><a href="#variable%3F-instance_method" title="SPARQL::Algebra::Expression#variable? (method)">#variable?</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


199
200
201</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 199</span>

<span class='def def kw'>def</span> <span class='constant? fid id'>constant?</span>
  <span class='notop op'>!</span><span class='lparen token'>(</span><span class='variable? fid id'>variable?</span><span class='rparen token'>)</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="evaluate-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>evaluate</strong>(bindings = {}) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Evaluates this expression using the given variable <code>bindings</code>.</p>

<p>This is the default implementation, which simply returns <code>self</code>.
Subclasses can override this method in order to implement something
more useful.</p>

  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='name'>bindings</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../RDF/Query/Solution.html" title="RDF::Query::Solution (class)">RDF::Query::Solution</a></span></tt>, <tt>#[]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>{}</tt>)</em>
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p><code>self</code></p></div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


224
225
226</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 224</span>

<span class='def def kw'>def</span> <span class='evaluate identifier id'>evaluate</span><span class='lparen token'>(</span><span class='bindings identifier id'>bindings</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='rparen token'>)</span>
  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="optimize-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>) <strong>optimize</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Returns an optimized version of this expression.</p>

<p>This is the default implementation, which simply returns <code>self</code>.
Subclasses can override this method in order to implement something
more useful.</p>

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="SPARQL::Algebra::Expression (module)">Expression</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p><code>self</code></p></div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


211
212
213</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 211</span>

<span class='def def kw'>def</span> <span class='optimize identifier id'>optimize</span>
  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_sse-instance_method">
  
    - (<tt><span class='object_link'><a href="../../Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_sse</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Returns the SPARQL S-Expression (SSE) representation of this expression.</p>

<p>This is the default implementation, which simply returns <code>self</code>.
Subclasses can override this method in order to implement something
more useful.</p>

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../../Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p><code>self</code></p></div>
      
    </li>
  
</ul>

  <h3>See Also:</h3>
  <ul class="see">
    
      <li><a href="http://openjena.org/wiki/SSE" target="_parent" title="http://openjena.org/wiki/SSE">http://openjena.org/wiki/SSE</a></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


237
238
239</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 237</span>

<span class='def def kw'>def</span> <span class='to_sse identifier id'>to_sse</span>
  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="variable?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>variable?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>Returns <code>false</code>.</p>

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p><code>true</code> or <code>false</code></p></div>
      
    </li>
  
</ul>

  <h3>See Also:</h3>
  <ul class="see">
    
      <li><span class='object_link'><a href="#variable%3F-instance_method" title="SPARQL::Algebra::Expression#variable? (method)">#variable?</a></span></li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


190
191
192</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'vendor/bundler/ruby/1.8/bundler/gems/sparql-algebra-058b98a0b601/lib/sparql/algebra/expression.rb', line 190</span>

<span class='def def kw'>def</span> <span class='variable? fid id'>variable?</span>
  <span class='false false kw'>false</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Wed Jun 29 20:35:14 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.7.2 (ruby-1.8.7).
</div>

  </body>
</html>